#!/usr/bin/env ruby

begin
  # Load bundler in dev environment. Rubygems generates a working binstub for stand-alone.
  require  'bundler/setup'
rescue LoadError
end

require 'aws-sdk-ec2'
require 'base64'
require 'clamp'
require 'ec2_kube_detox'
require 'k8s-client'
require 'retriable'
require 'rufus-scheduler'
require 'tempfile'
require 'time'
require 'tty-which'
require 'logger'

Log = Logger.new($stdout)
Log.level = ENV["DEBUG"].to_s.empty? ? Logger::INFO : Logger::DEBUG

Clamp do

  option '--aws-access-key', 'ACCESS_KEY', 'AWS access key ID', environment_variable: 'AWS_ACCESS_KEY_ID' do |aws_key|
    ENV['AWS_ACCESS_KEY_ID'] = aws_key
  end

  option '--aws-secret-key', 'SECRET_KEY', 'AWS secret access key', environment_variable: 'AWS_SECRET_ACCESS_KEY' do |aws_secret|
    ENV['AWS_SECRET_ACCESS_KEY'] = aws_secret
  end

  option '--kubectl', 'PATH', 'specify path to kubectl (default: use system default)' do |kubectl|
    File.executable?(kubectl) || signal_usage_error("kubectl at #{kubectl} not found or unusable")
    kubectl
  end

  option '--kube-config', 'PATH', 'Kubernetes config path', environment_variable: 'KUBECONFIG'
  option '--kube-server', 'ADDRESS', 'Kubernetes API server address', environment_variable: 'KUBE_SERVER'
  option '--kube-ca', 'DATA', 'Kubernetes certificate authority data', environment_variable: 'KUBE_CA'
  option '--kube-token', 'TOKEN', 'Kubernetes access token', environment_variable: 'KUBE_TOKEN'

  option '--max-age', 'DURATION', 'Maximum age of server before draining and terminating. (default: 3d)' do |max_age|
    if max_age.match?(/^\d+$/)
      to_sec("#{max_age}s")
    elsif max_age.match?(/^\d+[hmsdywM]$/)
      to_sec(max_age)
    else
      signal_usage_error 'invalid --max-age format'
    end
  end

  option '--keep', 'COUNT', 'keep at least COUNT nodes', default: 0 do |count|
    Integer(count)
  end

  option '--every', 'SCHEDULE', 'run periodically, example: --every 1h', attribute_name: :scheduler_proc do |every|
    unless every.match?(/^\d+[hmsdy]$/)
      signal_usage_error "invalid format for --every. use <number><unit>, example: 30s, 1h, 3d"
    end
    proc do |&block|
      Rufus::Scheduler.new.tap do |scheduler|
        scheduler.every every do
          Log.info "Running scheduled ec2 kubernetes node detox .."
          block.call
        end
      end.join
    end
  end

  option '--dry-run', :flag, "perform a dry-run, doesn't drain terminate any instances."

  execute do
    Log.debug { "Validating kube credentials" }
    kubectl

    scheduler do
      Log.debug { "Requesting node information .." }

      nodes = kube_client.api('v1').resource('nodes').list
      nodes.delete_if { |node| node.spec&.taints&.map(&:key)&.include?('node-role.kubernetes.io/master') }

      node_count = nodes.size
      Log.debug { "Kubernetes API lists %d nodes" % node_count }

      nodes.each do |node|
        if node_count <= keep
          Log.debug { "Node count equals to --keep #{keep}, breaking cycle" }
          break
        end

        name = node.metadata&.name
        Log.debug { "Node name %p" % name }
        next if name.nil?

        provider_id = node.spec&.providerID
        Log.debug { "Node provider_id: %p" % provider_id }
        if provider_id.nil? || !provider_id.start_with?('aws:///')
          Log.debug { "Node %s does not have a providerID" % name }
          next
        end

        region = node.metadata&.labels&.send(:'failure-domain.beta.kubernetes.io/region')
        Log.debug { "Node region: %p" % region }
        if region.nil?
          Log.debug { "Node %s does not have the metadata.labels[failure-domain.beta.kubernetes.io/region] region name" % name }
          next
        end

        node_id = provider_id[%r{aws:///.+?\/(.*)}, 1]
        Log.debug { "Node id: %p" % node_id }

        age_secs = (Time.now - Time.xmlschema(node.metadata.creationTimestamp)).to_i
        Log.debug { "Node %s (%s) age: %d seconds" % [name, provider_id, age_secs] }

        if age_secs > max_age
          Log.warn "!!! Node #{name} max-age expired, terminating !!!"

          node_count -= 1

          if dry_run?
            Log.info "[dry-run] Would drain node %s (%s)" % [name, node_id]
          else
            Log.debug { "Draining node %s (%s) .." % [name, node_id] }
            drain_node(name)
            Log.debug { "Done draining node %s (%s)" % [name, node_id] }
          end

          ec2_instance = ec2_resource(region).instance(node_id)

          Log.debug { "Node ec2 instance: %p" % ec2_instance }

          if ec2_instance.nil? || !ec2_instance.exists?
            Log.warn "ec2 instance %s (%s) not found" % [name, node_id]
            next
          end

          case ec2_instance.state.code
          when 48  # terminated
            Log.info "Node %s (%s) has already been terminated" % [name, node_id]
          else
            begin
              ec2_instance.terminate(dry_run: dry_run?)
            rescue Aws::EC2::Errors::DryRunOperation
              Log.info "[dry-run] Node termination dry-run check passed"
            rescue => ex
              if dry_run?
                Log.error "[dry-run] Node %s (%s) termination dry-run check reports an error: %s : %s" % [name, node_id, ex, ex.message]
              else
                Log.error "Failed to terminate node %s (%s): %s : %s" % [name, node_id, ex, ex.message]
                next
              end
            end
          end
        else
          Log.debug { "Node %s has not reached best-before" % name }
        end
      end

      Log.debug { "Round completed .." }
    end
  end

  def default_kubectl
    TTY::Which.which('kubectl') || signal_usage_error('kubectl not found in PATH, use --kubectl <path> to set location manually')
  end

  def drain_node(name)
    Retriable.retriable do
      Log.debug { "Running kubectl drain" }
      unless system(kubectl, "drain", '--kubeconfig=%s' % kube_config_file, '--timeout=5m', '--ignore-daemonsets', name)
        Log.error "kubectl drain failed"
        raise "kubectl drain failed"
      end
    end
  end

  def default_scheduler_proc
    proc do |&block|
      Log.debug { "Running using single-shot proc" }
      block.call
    end
  end

  def default_max_age
    to_sec('3d')
  end

  def to_sec(duration_string)
    num = duration_string[0..-2].to_i
    case duration_string[-1]
    when 's' then num
    when 'm' then num * 60
    when 'h' then num * 60 * 60
    when 'd' then num * 60 * 60 * 24
    when 'w' then num * 60 * 60 * 24 * 7
    when 'M' then num * 60 * 60 * 24 * 30
    when 'Y' then num * 60 * 60 * 24 * 365
    else
      signal_usage_error 'invalid --max-age format'
    end
  end

  private

  def scheduler(&block)
    scheduler_proc.call(&block)
  end

  def kube_client
    @kube_client ||= K8s::Client.config(K8s::Config.load_file(kube_config_file))
  end

  def kube_config_file
    return @kube_config_file if @kube_config_file

    if kube_config
      Log.debug { "using kubeconfig from --kube-config=%s" % kube_config }
      @kube_config_file = kube_config
    elsif kube_token || kube_server || kube_ca
      Log.debug { "using kubeconfig built from --kube-*" }
      unless kube_token && kube_server && kube_ca
        signal_usage_error "--kube-token --kube-server and --kube-ca are required to be used together"
      end
      @kube_config_file = temp_kubeconfig(token: kube_token, server: kube_server, ca: kube_ca)
    elsif File.exist?(File.join(Dir.home, '.kube', 'config'))
      Log.debug { "using kubeconfig from ~/.kube/config" }
      @kube_config_file = File.join(Dir.home, '.kube', 'config')
    elsif File.readable?('/etc/kubernetes/admin.conf')
      Log.debug { "using kubeconfig from /etc/kubernetes/admin.conf" }
      @kube_config_file = '/etc/kubernetes/admin.conf'
    else
      credentials = in_cluster_config
      signal_usage_error 'missing configuration for kubernetes credentials' if credentials.nil?
      Log.debug { "using kubeconfig from in_cluster_config" }
      @kube_config_file = temp_kubeconfig(credentials)
    end
  end

  def in_cluster_config
    credentials = {}

    host = ENV['KUBERNETES_SERVICE_HOST']
    port = ENV['KUBERNETES_SERVICE_PORT_HTTPS']
    return nil unless host && port
    credentials[:server] << "https://#{host}:#{port}"

    ca_file = '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'
    return nil unless File.readable?(ca_file)
    credentials[:ca] = File.read(ca_file)

    token_file = '/var/run/secrets/kubernetes.io/serviceaccount/token'
    return nil unless File.readable?(token_file)
    credentials[:token] = File.read(token_file)

    credentials
  end

  def temp_kubeconfig(token:, server:, ca:)
    begin
      token = Base64.strict_decode64(token)
    rescue ArgumentError # raised if token is not base64 encoded
    end

    tmpfle = Tempfile.new
    tmpfile << YAML.dump(
      clusters: [ { name: 'kubernetes', cluster: { server: server, certificate_authority_data: ca } } ],
      users: [ { name: 'ec2kubedetox', user: { token: token } } ],
      contexts: [ { name: 'ec2kubedetox', context: { cluster: 'kubernetes', user: 'ec2kubedetox' } } ],
      preferences: {},
      current_context: 'ec2kubedetox'
    )
    tmpfile.close
    tmpfile.path
  end

  def ec2_resource(region)
    # uses ENV variables, default config file or instance profile (when running on ec2) for credentials
    # the option parser sets the env variables when options are given
    Aws::EC2::Resource.new(region: region)
  end
end
